#pragma once
namespace bitcoin
{

    namespace detail{
    
        template<typename field_t /* modular integer algebra */, 
                 typename ec_t  /* static eliptic curve parameters */>
        class ec_point_t :
            public field_t, public ec_t
        {
            
            using integer_type = typename field_t::value_type;
            
            public:
            using value_type = field_t;
           
            private:
            bool my_identity{false};
            value_type my_x{}, my_y{};
            
            static bool check_point(value_type x, value_type y)
            {
                // const value_type a{elliptic_curve_parameters_t::a};
                // const value_type b{elliptic_curve_parameters_t::b};
                const value_type lhs = y*y;
                const value_type rhs = x*x*x  
                    + value_type{ec_t::a}*x 
                    + value_type{ec_t::b};
                return lhs == rhs;
            }
            
            public:
            
            auto x()const
            {
                return my_x.get();
            }
            auto y()const
            {
                return my_y.get();
            }
            
            static auto generator()
            {
                return ec_point_t{value_type{ec_t::Gx},value_type{ec_t::Gy}};
            }
            static auto identity()
            {
                return ec_point_t{};
            }
            
            // not guaranteed to produce a point generated by G
            // just a point in the curve
            ec_point_t(value_type in_x, value_type in_y):
                my_x{in_x}, my_y{in_y}
            {
                if(check_point(my_x,my_y)==false)
                    throw std::runtime_error("point does not belong to curve");
            }
            
            // not guaranteed to produce a point generated by G
            // just a point in the curve
            ec_point_t(value_type in_x, bool even=true):
                my_x{in_x}
            {
                value_type const y2  = my_x*my_x*my_x + value_type{ec_t::a}*my_x
                    + value_type{ec_t::b};
                my_y = sqrt(y2);
                
                if( even != is_even(my_y) )
                    my_y = -my_y;
            }
           
            bool is_identity()const
            {
                return my_identity;
            }
           
            // builds the identity
            ec_point_t()
            {
                my_identity=true;
            }
            
            auto& operator *= (const ec_point_t& that)
            {
                if(is_identity())
                {
                    // std::cout << "using ID * (x,y)\n";
                    *this = that;
                }else if(that.is_identity())
                {
                    // std::cout << "using (x,y) * ID\n";
                    // do nothing
                }
                else if(my_x!=that.my_x)
                {
                    // std::cout << "using (x1,y1) * (x2,y2)\n";
                    const value_type s = (that.my_y - my_y)/(that.my_x-my_x);
                    const value_type x3 = s*s - that.my_x - my_x;
                    const value_type y3 = s*(my_x-x3)-my_y;
                    
                    my_x=x3;
                    my_y=y3;
                }else if(my_y!=that.my_y)
                {
                    // std::cout << "using (x,y1)*(x,y2)\n";
                    my_x=my_y=value_type{};
                    my_identity = true;    
                }else
                {
                    // std::cout << "using (x,y)*(x,y)\n";
                    const value_type s = (value_type{3}*my_x*my_x+value_type{ec_t::a})
                        /(my_y+my_y);
                    const value_type x3=s*s - my_x - my_x;
                    const value_type y3=s*(my_x-x3)-my_y;
                    
                    my_x=x3;
                    my_y=y3;
                }
                
                return *this;
            }
        };
    } // namespace detail
    template<typename T1,typename T2>
    detail::ec_point_t<T1,T2> operator * (
        const detail::ec_point_t<T1,T2>& x, 
        const detail::ec_point_t<T1,T2>& y)
    {
        detail::ec_point_t<T1,T2> z{x};
        return z*=y;
    }
} // namespace bitcoin
